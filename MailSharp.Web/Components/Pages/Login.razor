@page "/login"
@inject NavigationManager Navigation
@inject IJSRuntime JS

<EditForm Model="@loginModel" OnValidSubmit="HandleLogin" FormName="loginForm">
    <DataAnnotationsValidator />
    <ValidationSummary />

    <div class="form-group mb-3">
        <label for="email">E-mail</label>
        <InputText id="email" class="form-control" @bind-Value="loginModel.Email" />
        <ValidationMessage For="@(() => loginModel.Email)" />
    </div>

    <div class="form-group mb-3">
        <label for="password">Senha</label>
        <InputText id="password" class="form-control" @bind-Value="loginModel.Password" type="password" />
        <ValidationMessage For="@(() => loginModel.Password)" />
    </div>

    <button type="submit" class="btn btn-danger w-100" disabled="@isProcessing">Entrar</button>

    @if (!string.IsNullOrEmpty(errorMessage))
    {
        <div class="alert alert-danger mt-3">@errorMessage</div>
    }
</EditForm>

@code {
    private LoginRequest loginModel = new();
    private string? errorMessage;
    private bool isProcessing;

    private bool _interactive;

    protected override Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _interactive = true;
        }

        return Task.CompletedTask;
    }

    private async Task HandleLogin()
    {
        if (!_interactive)
        {
            errorMessage = "Aguarde a inicialização do cliente...";
            return;
        }

        errorMessage = null;
        isProcessing = true;
        await InvokeAsync(StateHasChanged);

        try
        {
            // Chamada feita no browser via JS fetch para que o Set-Cookie do servidor seja entregue
            var result = await JS.InvokeAsync<object>("mailsharp.postJson", "/auth/proxy-login", loginModel);
            // result é um objeto com { status, ok, body }
            var status = await ((IJSInProcessObjectReference)result).InvokeAsync<int>("eval", "this.status");
            var ok = await ((IJSInProcessObjectReference)result).InvokeAsync<bool>("eval", "this.ok");
            // fallback: usar dinâmica (não ideal), mas verificar via JSON string se necessário
            // Para simplicidade, vamos extrair via JSON no C#:
            var json = System.Text.Json.JsonSerializer.Serialize(result);
            var parsed = System.Text.Json.JsonSerializer.Deserialize<JsonResponse?>(json);

            if (parsed is not null && parsed.ok)
            {
                // Cookies HttpOnly já gravados no browser. Navegar.
                try
                {
                    await InvokeAsync(() => Navigation.NavigateTo("/"));
                }
                catch (Microsoft.AspNetCore.Components.NavigationException)
                {
                    Navigation.NavigateTo("/", forceLoad: true);
                }
            }
            else
            {
                if (parsed != null && parsed.status == 401)
                    errorMessage = "Usuário ou senha inválidos.";
                else
                    errorMessage = $"Erro ao efetuar login ({parsed?.status}).";
            }
        }
        catch (JSException jsEx)
        {
            errorMessage = $"Erro na chamada cliente: {jsEx.Message}";
        }
        catch (Exception ex)
        {
            errorMessage = $"Erro no login: {ex.Message}";
        }
        finally
        {
            isProcessing = false;
            await InvokeAsync(StateHasChanged);
        }
    }

    public class LoginRequest
    {
        public string Email { get; set; } = string.Empty;
        public string Password { get; set; } = string.Empty;
    }

    private class JsonResponse
    {
        public int status { get; set; }
        public bool ok { get; set; }
        public string? body { get; set; }
    }
}